<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Division Race Probabilities</title>
    <link href="output.css" rel="stylesheet">
</head>

<body class="bg-gray-100 p-8">
    <div class="max-w-md mx-auto bg-white rounded-xl shadow-md overflow-hidden md:max-w-2xl">
        <div class="p-8">
            <h1 class="text-2xl font-bold mb-4">Division Race Probabilities</h1>
            <p>Let's say we have two baseball teams in a division, we're about halfway through
                the season, and we want to see how likely each team is to win the division at the
                end of the season.</p>
            <division-element readonly="true">
                <team-games-back team-name="Astros" games-back="0"></team-games-back>
                <team-games-back team-name="Blue Jays" games-back="3"></team-games-back>
            </division-element>
            <br><br>
            <division-element></division-element>
            <details><summary></summary>
                <button id="runTests" class="bg-yellow-500 text-white px-4 py-2 rounded">Run tests</button>
                <div id="testResults"></div>
            </details>
        </div>
    </div>
    <script>
// TODO
// - margins, especially for editable
// - centering for editable
// - pie chart? (this won't work with > 1)
function accumulateSimulationResults(results, wins) {
    // Array.toSorted() isn't quite widely supported enough yet...
    let sortedWins = [...wins];
    sortedWins.sort((a,b) => b - a);
    // Ties are annoying.
    // We will handle this by saying if there are N teams
    // tied for second place, each team will get 1/N of a
    // win for second place through (2+N-1)th place.
    let lastValue = sortedWins[0] + 1;
    let winsIndex = 0;
    let currentPosition = 0;
    while (winsIndex < sortedWins.length) {
        let lastWinsIndex = winsIndex;
        while (sortedWins[winsIndex] === lastValue && winsIndex < sortedWins.length)  {
            winsIndex++;
        }
        let numberOfTies = winsIndex - lastWinsIndex;
        for (let k = 0; k < sortedWins.length; k++) {
            if (wins[k] === sortedWins[winsIndex - 1]) {
                for (let m = 0; m < numberOfTies; m++) {
                    results[k][currentPosition+m] += 1.0 / numberOfTies;
                }
            }
        }
        currentPosition += numberOfTies;
        if (winsIndex < sortedWins.length) {
            lastValue = sortedWins[winsIndex];
        }
    }
}
function simulateDivision(gamesBackArray, gamesLeft, iterations) {
    if (gamesBackArray.length === 0) {
        return [];
    }
    let results = Array.from(gamesBackArray.map(_ => new Array(gamesBackArray.length).fill(0)));
    // This whole thing is really inefficient, but
    // modern computers are fast so I'm going to live
    // with it for now.
    for (let i = 0; i < iterations; i++) {
        let wins = gamesBackArray.map(x => -1 * x);
        for (let g = 0; g < gamesLeft; g++) {
            for (let j = 0; j < wins.length; j++) {
                wins[j] += Math.floor(Math.random() * 2);
            }
        }
        accumulateSimulationResults(results, wins);
    }
    return results;
}
class TeamGamesBack extends HTMLElement {
    constructor() {
        super();
        this._simulationsUpToDate = true;
        this.attachShadow({ mode: 'open' });
    }

    connectedCallback() {
        this.render();
    }
    get readonly() {
        return this.getAttribute('readonly') === "true";
    }
    get gamesBack() {
        return parseInt(this.getAttribute('games-back'), 10);
    }
    set gamesBack(value) {
        if (value.toString() !== this.gamesBack) {
            this.setAttribute('games-back', value);
            this.dispatchEvent(new CustomEvent("team-changed", {
                bubbles: true,
                composed: true
            }));
        }
    }
    get teamName() {
        return this.getAttribute('team-name').trim();
    }
    set teamName(value) {
        this.setAttribute('team-name', value.trim());
    }
    set qualifyPercentage(value) {
        this.setAttribute('qualify-percentage', value);
    }
    get qualifyPercentage() {
        return this.getAttribute('qualify-percentage');
    }

    render() {
        /*this.shadowRoot.innerHTML = `
            <link rel="stylesheet" href="output.css">
            <li class="flex justify-between items-center py-2">
                <input type="text" value="${this.teamName}" class="border rounded px-2 py-1 w-24 mr-2">
                <input type="number" value="${this.gamesBack}" placeholder="0.0" step="0.5" min="0" class="border rounded px-2 py-1 w-24 mr-2">
                <button class="delete-btn bg-red-500 text-white px-2 py-1 rounded">Delete</button>
            </li>
        `;*/
        let winPercentageText = "";
        if (this.qualifyPercentage !== null) {
            winPercentageText = (Math.round(Number.parseFloat(this.qualifyPercentage) * 1000) / 10 ) + "%";
        }
        let winPercentageDiv = `<div class="${this._simulationsUpToDate ? "" : "outOfDate"}">${winPercentageText}</div>`;
        const readonlyHtml = `
            <div>${this.teamName}</div>
            <div>${this.gamesBack}</div>
            ${winPercentageDiv}
            <div></div>
        `;
        // Don't allow half-games - it doesn't make sense if every team
        // has the same number of games left to play.
        const editableHtml = `
            <input type="text" class="teamName" value="${this.teamName}" class="border rounded px-2 py-1">
            <input type="number" class="gamesBack" value="${this.gamesBack}" min="0" class="border rounded px-2 py-1">
            ${winPercentageDiv}
            <button class="delete-btn bg-red-500 text-white px-2 py-1 rounded">Delete</button>
        `;
        this.shadowRoot.innerHTML = `
            <link rel="stylesheet" href="output.css">
            <style>
                div.outOfDate { color: grey; }
            </style>
            <div class="grid grid-cols-4">
            ${this.readonly ? readonlyHtml : editableHtml}
            </div>
        `;

        if (!this.readonly) {
            this.shadowRoot.querySelector('input.teamName').addEventListener('change', (e) => {
                this.teamName = e.target.value;
            });
            this.shadowRoot.querySelector('input.gamesBack').addEventListener('change', (e) => {
                this.gamesBack = e.target.value;
            });
            this.shadowRoot.querySelector('.delete-btn').addEventListener('click', () => {
                this.dispatchEvent(new CustomEvent("team-changed", {
                    bubbles: true,
                    composed: true
                }));
                this.remove();
            });
            document.addEventListener("up-to-date-changed", e => {
                this._simulationsUpToDate = e.detail.upToDate;
                this.render();
            });
        }
    }
}

customElements.define('team-games-back', TeamGamesBack);

class Division extends HTMLElement {
    constructor() {
        super();
        this._simulationsUpToDate = true;
        this.attachShadow({ mode: 'open' });
    }
    connectedCallback() {
        this.render();
        this.setupEventListeners();
        this.processInitialChildren();
    }
    makeFakeName(index) {
        switch (index) {
            case 0:
                return "Astros";
            case 1:
                return "Blue Jays";
            case 2:
                return "Cubs";
            case 3:
                return "Dodgers";
            case 4:
                return "Eagles";
            case 5:
                return "Falcons";
            case 6:
                return "Giants";
            case 7:
                return "Heat";
            case 8:
                return "Islanders";
            case 9:
                return "Jazz";
        }
        return `Team ${index + 1}`;
    }
    setupEventListeners() {
        this.shadowRoot.getElementById('addItem')?.addEventListener('click', () => this.addItem());
        this.shadowRoot.getElementById('numberOfWinningTeams')?.addEventListener('change', (e) => {
            this.setAttribute('winningTeams', e.target.value);
        });
        this.shadowRoot.getElementById('simulate').addEventListener('click', () => {
            const items = this.shadowRoot.querySelectorAll('team-games-back');
            const gamesBackArray = Array.from(items).map(item => item.gamesBack);
            const GAMES = 80;
            const NUM_ITERATIONS = 3000;
            let results = simulateDivision(gamesBackArray, GAMES, NUM_ITERATIONS);
            this.simulationsUpToDate = true;
            items.forEach((item, index) => {
                item.qualifyPercentage = results[index].slice(0, this.numberOfWinningTeams).reduce((sum, v) => sum + v) / NUM_ITERATIONS;
                item.render();
            });
        });
        document.addEventListener("team-changed", e => {
            this.simulationsUpToDate = false;
        });
    }
    processInitialChildren() {
        const itemList = this.shadowRoot.getElementById('itemList');
        let childrenArray = Array.from(this.children)
            .filter(child => child.tagName.toLowerCase() === 'team-games-back');
        const isEmpty = childrenArray.length === 0;
        childrenArray.forEach(child => {
            if (child.tagName.toLowerCase() === 'team-games-back') {
                child.setAttribute('readonly', this.readonly);
                let newDiv = document.createElement("div");
                newDiv.classList.add("col-start-1", "col-end-5");
                newDiv.appendChild(child);
                itemList.appendChild(newDiv);
            }
        });
        if (isEmpty) {
            this.addItem();
        }
    }
    get numberOfWinningTeams() {
        const winningTeams = parseInt(this.getAttribute('winningTeams'), 10);
        return (winningTeams && !isNaN(winningTeams)) ? winningTeams : 1;
    }
    get readonly() {
        return this.getAttribute('readonly') === "true";
    }
    render() {
        const addItemHtml = `<div class="mb-4">
                <button id="addItem" class="bg-blue-500 text-white px-4 py-1 rounded">Add New Item</button>
            </div>`;
        const numberOfWinningTeamsReadonlyHtml = `Top ${this.numberOfWinningTeams} teams advance`;
        const numberOfWinningTeamsEditableHtml = `Top <input type="number" value="${this.numberOfWinningTeams}" min="1" max="10" style="width: 35px;" id="numberOfWinningTeams"> teams advance`;
        this.shadowRoot.innerHTML = `
            <link rel="stylesheet" href="output.css">
            ${!this.readonly ? addItemHtml : ""}
            <div>${this.readonly ? 
                    ((this.numberOfWinningTeams > 1) ?  numberOfWinningTeamsReadonlyHtml : "")
                    : numberOfWinningTeamsEditableHtml}</div>
            <div class="grid grid-cols-4" id="itemList">
                <div>Team</div><div>Games back</div><div>Win %</div><div></div>
            </div>
            <button id="simulate" class="bg-green-500 text-white px-4 py-2 rounded">Simulate Division</button>
        `;
    }
    get simulationsUpToDate() {
        return this._simulationsUpToDate;
    }
    set simulationsUpToDate(value) {
        if (this._simulationsUpToDate !== value) {
            this._simulationsUpToDate = value;
            this.dispatchEvent(new CustomEvent("up-to-date-changed", {
                detail: {upToDate: value},
                bubbles: true,
                composed: true
            }));
        }
    }
    addItem() {
        this.simulationsUpToDate = false;
        const team = document.createElement('team-games-back');
        team.setAttribute('games-back', '0');
        team.setAttribute('readonly', this.readonly);
        const existingItems = this.shadowRoot.querySelectorAll('team-games-back');
        let existingNames = new Set();
        existingItems.forEach(elem => existingNames.add(elem.teamName));
        let index = existingItems.length;
        let name;
        do {
            name = this.makeFakeName(index);
            index++;
        } while (existingNames.has(name));
        team.setAttribute('team-name', name);
        let newDiv = document.createElement("div");
        newDiv.classList.add("col-start-1", "col-end-5");
        newDiv.appendChild(team);
        this.shadowRoot.getElementById('itemList').appendChild(newDiv);
    }
}

customElements.define('division-element', Division);

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById("runTests").addEventListener('click', () => {
        function assert(expected, actual, description) {
            if (expected - actual >= 0.01) {
                throw `${description} - expected ${expected}, actual ${actual}`;
            }
        }
        function assertResults(expected, actual, description) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    assert(expected[i][j], actual[i][j], `${description} element[${i}][${j}]`);
                }
            }
        }
        function runTest(wins, expectedResults) {
            let results = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
            accumulateSimulationResults(results, wins);
            assertResults(expectedResults, results, `${wins}`);
        }
        document.getElementById("testResults").innerHTML = "";
        try {
            runTest([4, 6, 5], [[0, 0, 1], [1, 0, 0], [0, 1, 0]]);
            runTest([4, 4, 5], [[0, 0.5, 0.5], [0, 0.5, 0.5], [1, 0, 0]]);
            runTest([5, 4, 5], [[0.5, 0.5, 0], [0, 0, 1], [0.5, 0.5, 0]]);
            runTest([5, 5, 5], [[0.333, 0.333, 0.333], [0.333, 0.333, 0.333], [0.333, 0.333, 0.333]]);
        }
        catch (failure) {
            let div = document.createElement("div");
            div.classList.add("bg-red-500");
            div.classList.add("text-white");
            div.appendChild(document.createTextNode(`Tests failed: ${failure}`));
            document.getElementById('testResults').appendChild(div);

        }
        if (document.getElementById('testResults').children.length === 0) {
            let div = document.createElement("div");
            div.classList.add("bg-green-500");
            div.classList.add("text-white");
            div.appendChild(document.createTextNode("Tests passed!"));
            document.getElementById('testResults').appendChild(div);
        }
    });
});
</script>
 
</body>
</html>
